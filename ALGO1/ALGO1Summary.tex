% !TeX spellcheck = fr_FR ----------- %
% ----------------------------------- %
% ----SUMMARY-OF-ALGO-1-COURSE------- %
% ----------------------------------- %
% -@version-1.0---------------------- %
% -@author-Florestan-De-Moor--------- %
% ----------------------------------- %


\documentclass[10pt,a4paper]{article}

\usepackage[frenchb]{babel}

\usepackage[utf8]{inputenc}

\usepackage{amsmath}

\usepackage{amsfonts}

\usepackage{amssymb}

\usepackage{enumitem} % To set no item separation

% Redefine the itemize symbol
	\AtBeginDocument{\def\labelitemi{\( \vartriangleright \)}}

\begin{document}


\title{Algorithmique 1}
\author{L3 RI}
\date{}

\maketitle

\tableofcontents


\section{Algorithmes}

\subsection{Tris}

%
\begin{itemize}[noitemsep]
	\item Tri par insertion : \(  O(n^2)  \)
		
		Considérer chaque élément un à un pour l'insérer à sa bonne place (penser à un jeu de cartes)
		
	\item Tri fusion : \(  O(n\log n)  \)
		
		Paradigme diviser pour régner, diviser en deux sous-problèmes
	\item Tri Shell : \(  O(n^2)  \)
	
		Suite de tris par insertion sur chaque constituant d'une partition du tableau
		
	\item Tri par tas : \(  O(n\log n)  \)
	
		Utiliser une structure de file de priorité, ici un tas
	\item Optimalité : \(  \Omega (n \log n)  \) nécessaire, arbres de décision
\end{itemize}
%



\subsection{Arbres binaires}

%
\begin{itemize}[noitemsep]
	\item Arbre binaire : \(  1+h \leq n \leq 2^{h+1}-1  \)
	\item Arbre binaire presque complet : %
		\(  2^h \leq n \leq 2^{h+1}-1  \)
	\item Tas
	\item Arbre binaire de recherche (ABR)
	
		La recherche d'un élément ne suit qu'une branche, problème si arbre non équilibré
	\item Arbre AVL
	
		Rééquilibrage d'un arbre par des rotations :
		\(  \log _2(n+1) \leq h \leq 1.44\log _2 n  \)
	
\end{itemize}
%



\subsection{Graphes}

%
\begin{itemize}[noitemsep]
	\item Graphes orientés, pondérés
	\item Implémentations par liste d'adjacence ou matrice d'adjacence
	\item Parcours en profondeur
	
		Valeurs de \texttt{Pre} et \texttt{Post} traitement, types d'arc, détection de cycles, tri topologique, composantes fortement  connexes (\emph{Algorithme de Kosaraju}), graphe quotient
	\item Parcours en largeur
	
		Recherche d'un plus court chemin (\emph{Algorithme de Dijkstra}, \emph{algorithme A\(^*\)})
	\item Arbre couvrant de poids minimal (\emph{Algorithme de Kruskal}, \emph{Algorithme de Prim})
\end{itemize}
%


\subsection{Algorithmes gloutons}

\begin{itemize}[noitemsep]
	\item Prendre un choix localement meilleur
	\item Algorithmes de Kruskal, de Prim
	\item Rendu de monnaie
	\item Couverture d'ensemble (exemple où le choix glouton ne donne pas forcément la solution optimale)
\end{itemize}


\subsection{Programmation dynamique}

\begin{itemize}[noitemsep]
	\item Paradigme de conception d'algorithmes
	\item Définir les sous-problèmes, en revoyant à la baisse l'objectif si nécessaire
	\item Trouver une relation de récurrence
	\item Écrire l'algorithme (mémoïzation)
	\item Exemples
	
		Recherche plus court chemin dans un graphe (\emph{Algorithme de Floyd-Warshall}, \emph{algorithme de Bellman-Ford}), recherche plus longue sous-suite croissante, problème du sac à dos
\end{itemize}


\subsection{Flots}

\begin{itemize}[noitemsep]
	\item Problème du flot maximal
	\item Algorithme de Ford-Fulkerson
	\item Réduction du problème de couplage maximal au problème de flot maximal
\end{itemize}


\subsection{Programmation linéaire}

\begin{itemize}[noitemsep]
	\item Forme canonique
	\item Algorithme du simplexe
\end{itemize}


\section{Structures de données}

%
\subsection{Files de priorité}

Implémentées par exemple avec un tas.

Méthodes : 
\begin{itemize}[noitemsep]
	\item Enfiler
	\item Défiler un élément maximal
	\item Est vide?
	\item Construire file vide
\end{itemize}

\subsection{Tables de hachage}
	
Méthodes : 
\begin{itemize}[noitemsep]
	\item Ajout d'un élément
	\item Suppression d'un élément
	\item Contient x ?
\end{itemize}

Risques de collision, n'est pas rare (idem paradoxe des anniversaires)

\subsection{Structure Union-Find}

Méthodes : 
\begin{itemize}[noitemsep]
	\item Créer partition
	\item Fusionner deux classes (union)
	\item Obtenir un représentant (find)
\end{itemize}

Implémentation par une forêt d'arbres. %
Complexité améliorée en utilisant la compression de chemin.




\section{Autres}

\begin{itemize}[noitemsep]
	\item Encodage de Huffman
	\item Formules de Horn
	\item FFT
	\item Classes P, NP, EXPTIME
	\item Classe NP : Réduction à SAT, Branch\&Bound, Local Search
\end{itemize}

\end{document}